<!DOCTYPE html>
<html class="no-js gr__localhost" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Purr</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="." />
    <link rel=icon href=/images/cat_sitting.png>
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
      integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css"
      integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp"
      crossorigin="anonymous"
    />
    <!--[htmlclean-protect]-->
    <!-- inject:css -->
    <link rel="stylesheet" href="css/style.css" />
    <!-- endinject -->
    <!--[/htmlclean-protect]-->
  </head>

  <body>
    <!--[htmlclean-protect]-->
    <!-- inject:js -->
    <script src="gulpfile.js"></script>
    <script src="js/script.js"></script>
    <!-- endinject -->
    <!--[/htmlclean-protect]-->
    <!-- <ul class="nav nav-pills justify-content-end">
   
      
    </ul> -->
    <nav class="nav nav-pills">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="#">Purr</a>
        </div>
        <ul class="nav navbar-nav">
          <!-- <li class="nav-item">
                <a data-scroll="" href="#home" class="nav-link">Home</a>
              </li> -->
        </ul>
        <ul class="nav navbar-nav navbar-right">
          <li class="nav-item">
            <a data-scroll="" href="index.html" class="nav-link">Home</a>
          </li>
          <li class="nav-item">
            <a data-scroll="" href="about.html" class="nav-link">About</a>
          </li>
          <li class="nav-item ">
            <a data-scroll="" href="#get_started" class="nav-link get-started"
              >Get started</a
            >
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">Docs</a>
          </li>
          <li class="nav-item">
            <a data-scroll="" href="#contribute" class="nav-link">Contribute</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">FAQ</a>
          </li>
          <li class="nav-item">
            <a data-scroll="" href="#contact" class="nav-link disabled"
              >Contact</a
            >
          </li>
        </ul>
      </div>
    </nav>

    <div id="docs" class="content">
      <div class="row row-dark align-middle vertical-center">
        <div class="col-md-1"></div>
        <div class="col-md-10">
          <h1>
            Documentation
          </h1>
          <h4>Purr v1</h4>
        </div>
        <div class="col-md-1"></div>
      </div>

      <div class="row banner">
        <div class="col-md-1"></div>
        <div class="col-md-10">
          <a data-scroll="" class="nav-link button-light">View on Github</a>
        </div>
        <div class="col-md-1"></div>
      </div>

      <div class="row row-light">
        <div class="col-md-1"></div>
        <div class="col-md-10">
          <div class="col-md-4 menu">
            <ul class="bullet">
              <li>Setup</li>
              <li>Requirements</li>
              <li>Support</li>
              <li>Quickstart</li>
              <li>
                <span>
                  v1
                </span>
                <ul>
                  <li>Setup file</li>
                  <li>Command line options</li>
                  <li>Collection Map</li>
                  <li>Data types</li>
                  <li>Extra properties</li>
                  <li>Tailing</li>
                  <li>Errors</li>
                </ul>
              </li>
              <li>
                <span>
                  How to Contribute
                </span>
                <ul>
                  <li>Guidelines</li>
                </ul>
              </li>
            </ul>
          </div>
          <div class="col-md-8 docs-text">
            <h1>
              Setup
            </h1>
            Install requirements locally: pip install -r requirements.txt
            Install Purr:
            <code>
              python setup.py install
            </code>
            <h2>
              Requirements
            </h2>
            <p>
              Install requirements locally:
            </p>
            <code>
              pip install -r requirements.txt
            </code>
            <p>
              Install Purr:
            </p>
            <div></div>
            <code>
              python setup.py install
            </code>

            <h2>Support</h2>
            <p>MongoDB 3.4</p>
            <p>PostgreSQL 9.6</p>

            <div>
              <ol>
                <li>Install requirements and Purr</li>
                <li>Create a YAML file which contains the collection map</li>
                <li>start Mongo as a replica set</li>
                <li>start Postgres as a replica set</li>
                <li>
                  <p>
                    On the command line type:
                  </p>
                  <code>
                    purr -cf path/to/collections.yml -pg
                    postgres://127.0.0.1:5432/postgres -mdb
                    mongodb://localhost:27017 -n db_name -t
                  </code>
                </li>
              </ol>
              <p>
                With this quickstart, the following happens: After transfering
                all collections to the public schema, Purr starts tailing the
                oplog.
              </p>
              <p>
                Make changes to any of your documents and check what happens in
                your Postgres database.
              </p>
            </div>
            <h2>
              Usage
            </h2>
            <p>
              After installing Purr, you will need a collection map to describe
              your schema. Without the collection map you can not start Purr.
              Once you created your collection map, you should have a running
              MongoDB instance as a source and Postgres as a target database.
              You can start Purr using command line options or you can create
              another YAML file to organize your settings. The collection map
              and the setup file should not be mixed.
            </p>
            <h3>Setup file</h3>
            <p>
              <code>-h, --help </code>show help message
              <code>-sf, --setup-file </code>
            </p>
            <p>
              The setup file must have the following form: path to YAML file
              which contains settings Starting Purr without using a setup file:
            </p>
            <h4>
              Settings for Postgres:
            </h4>
            <ul>
              <li>
                db_name: name of database
              </li>
              <li>
                connection: connection string to database
              </li>
              <li>
                schema_name: name of schema where the collections will be
                transfered to
              </li>
              <li>
                schema_reset:
                <ul>
                  <li>true: reset existing schema</li>
                  <li>false: keep existing schema</li>
                </ul>
              </li>
              <li>
                table_truncate: truncate table before starting data transfer
              </li>
              <li>
                table_drop: drop table before starting data transfer
              </li>
            </ul>
            <h4>
              Settings for MongoDB
            </h4>
            <ul>
              <li>
                db_name: name of database
              </li>
              <li>
                connection: connection string to database
              </li>
            </ul>
            <h4>General Settings</h4>
            <ul>
              <li>
                tailing: keep tailing the oplog after collection transfer is
                finished
              </li>
              <li>
                typecheck_auto:
                <ul>
                  <li>
                    true: let Purr decide the data type for each field
                  </li>
                  <li>
                    false: use a YAML file to describe collection types
                    (<code>-cf</code>)
                  </li>
                </ul>
              </li>
              <li>
                include_extra_props: include properties which are not described
                in the collection map
              </li>
            </ul>
            <p></p>
            <code> purr -sf path/to/setup.yml -cf path/to/collections.yml</code>
            <h3>Command line options</h3>
            <p>
              You can set all the variables from the previous section using the
              command line. Passing connection strings to MongoDB and Postgres
              is mandatory.
            </p>
            <ul>
              <li>
                -sf or --setup-file: path to the setup file if exists
              </li>
              <li>
                -cf or --collection-file: path to the collection file if exists
              </li>

              <li>-td or --table-drop: defaults to false</li>
              <li>-tt or --table-truncate: defaults to false</li>
              <li>-sr or --schema-reset: defaults to false</li>
              <li>-sn or --schema-name: defaults to public</li>
              <li>
                <code>-pg</code> or <code>--pg-connection</code>: connection
                string to PG database (*)
              </li>
              <li>
                -mdb or --mongo-connection: connection string to Mongo database
                (*)
              </li>
              <li>
                -n or --mongo-db-name: equivalent of db_name for MongoDB (*)
              </li>
              <li>-t or --tail: equivalent of tailing; defaults to false</li>
              <li>
                -s or --start: equivalent of tailing_from; type should be date,
                defaults to None
              </li>

              <li>
                -tsdb or --start-from-tsdb: equivalent of tailing_from_db;
                defaults to false
              </li>
              <li>-ta or --typecheck-auto: defaults to false</li>

              <li>-ex or --include-extra-properties: defaults to false</li>
            </ul>

            <p>Starting Purr without using a setup file:</p>
            <code
              >purr -cf path/to/collections.yml -pg
              postgres://127.0.0.1:5432/postgres -mdb mongodb://localhost:27017
              -n mongo_db_name -t</code
            >

            <p class="note">
              <i>Variables followed by (*) are mandatory.</i>
            </p>

            <h5>Example setup.yml</h5>
            <pre>
               postgres: 
                  db_name: my_pg_database
                  connection: postgres://127.0.0.1:5432/postgres
                  schema_name: maine_coon
                  schema_reset: false
                  table_truncate: false
                  table_drop: false
               mongo:
                  db_name: my_mongo_database
                  connection: mongodb://localhost:27017
               tailing: true
               typecheck_auto: false
               include_extra_props: true
              </pre
            >
            <hr />
            <h2>Collection Map</h2>
            <code>
              -cf, --collection-file
            </code>
            <p>
              The collection map is a YAML file which contains information about
              the database and the collections you want to transfer. Only the
              collections that are described here will be loaded to your
              Postgres database, other collections will be ignored.
            </p>
            <p>
              The collection map should have the following structure:
            </p>
            <pre>
              mongo_database_name:
                Collection1:
                  :columns:
                    - column1:
                      :source: field1
                      :type: TEXT
                    - column2:
                      :source: field2
                      :type: TEXT
                  :meta:
                    :table: collection1
                    :extra_props: JSONB
                Collection2:
                  :columns:
                    - column3:
                      :source: field3
                      :type: TEXT
                    - column4:
                      :source: field4
                      :type: TEXT
                    - ...
                  :meta:
                    :table: collection2
                    :extra_props: JSONB
            </pre>
            <h5>Example setup.yml</h5>

            <pre>
              my_mongo_database:
                Cat:
                  :columns:
                    - id:
                      :source: _id
                      :type: TEXT
                    - name:
                      :source: name
                      :type: TEXT
                    - active:
                      :source: active
                      :type: BOOLEAN
                    - number_of_legs:
                      :source: numberOfLegs
                      :type: DOUBLE PRECISION
                    - created_at:
                      :source: createdAt
                      :type: TIMESTAMP
                  :meta:
                    :table: cat
                    :extra_props: JSONB
            </pre>
            <p>
              Explanation: When connecting to the Mongo instance, Purr looks for
              the database name in the collection map
              (<i>my_mongo_database</i>). Collection <i>Cat</i> will be
              transferred to table <i>cat</i> (described under meta -> table).
              This table will have 6 columns with the following types
            </p>
            <pre>
              id: text
              name: text
              active: boolean
              domains: jsonb
              created_at: text
              extra_props: jsonb
            </pre>
            <h4>
              Data Types
            </h4>

            <p>
              Purr uses 5 different data types when creating rows for a table:
            </p>
            <ul>
              <li>boolean</li>
              <li>double precision</li>
              <li>text</li>
              <li>timestamp</li>
              <li>jsonb</li>
            </ul>

            <h5>
              Conversion
            </h5>
            <p>
              When you already have a schema and decide to re-run Purr with a
              changed collection map, you will have to keep a couple of things
              in mind.
            </p>
            <p>
              The following table shows what happens when a schema change
              happens
            </p>
            <!-- wtf: -->
            <!-- rows = A columns = B converting A to B -->

            <table class="table">
              <th></th>
              <th>boolean</th>
              <th>double precision</th>
              <th>text</th>
              <th>timestamp</th>
              <th>jsonb</th>
              <tbody>
                <tr>
                  <td>boolean</td>
                  <td>✓</td>
                  <td></td>
                  <td>✓</td>
                  <td></td>
                  <td>✓</td>
                </tr>
                <tr>
                  <td>double precision</td>
                  <td></td>
                  <td>✓</td>
                  <td>✓</td>
                  <td></td>
                  <td>✓</td>
                </tr>
                <tr>
                  <td>text</td>
                  <td></td>
                  <td></td>
                  <td>✓</td>
                  <td></td>
                  <td>✓</td>
                </tr>
                <tr>
                  <td>timestamp</td>
                  <td></td>
                  <td></td>
                  <td>✓</td>
                  <td>✓</td>
                  <td>✓</td>
                </tr>

                <tr>
                  <td>jsonb</td>
                  <td></td>
                  <td></td>
                  <td>✓</td>
                  <td></td>
                  <td>✓</td>
                </tr>
              </tbody>
            </table>

            <p>
              Conversions that have ✔, can be easily handled by Postgres. When
              you assign a new type and your data is not castable to your new
              type, Purr will have to handle that situation on its own. Purr
              will rename your inconsistent column to column_name_old and create
              a new one with the new data type under column_name. This way we
              can make sure that you will not lose any data and you can continue
              working on your new column. Purr will restart collection transfer
              for that specific collection and will try to cast your values so
              they fit into your new column. If casting cannot be done, you will
              have NULLs instead of a value.
            </p>

            <p>
              Keeping the old version of your column gives you more control over
              your data: you decide what to do with the values which could not
              be casted and inserted into the new column. When you re-run Purr
              again, your old column will be deleted since it's not part of the
              collection map. Feel free to drop the old column at any moment (if
              you are sure that you don't need it).
            </p>
            <p>
              When you are tailing and a type change happens in your Mongo
              database, Purr will try to cast your data to the current column's
              type. If not succeeded, Purr will log a warning and continue
              tailing.
            </p>

            <h4>Extra properties</h4>
            <p>
              Extra properties are properties of a document in MongoDB which do
              not have their name, source and type in the collection map. Having
              extra properties means that values which are not defined in the
              collection map will be part of a column named extra_props with
              type defined based on the collection map. Leaving out extra
              properties from the collection map will make extra_props type
              default to JSONB.
            </p>
            <p>
              In case that you want to include extra properties you have to
              start Purr with option -ex.
            </p>
            <p>
              If you already have an extra_props column but you restarted Purr
              without this option, all columns named extra_props one by one.
            </p>
            <ul>
              <li>
                drop column extra_props for Collection1
              </li>
              <li>drop columns that are not in the collection map</li>
              <li>
                start transfer ... and so on for the other collections
              </li>
            </ul>
            <p>
              Starting Purr without extra properties can be significantly
              faster.
            </p>

            <p>
              Example: start Purr using a setup file and collections described
              in collections.yml
            </p>
            <code>
              purr -sf setup.yml -cf collections.yml
            </code>
            <p>
              Example: start Purr without setup file (tailing mode)
            </p>

            <code>
              purr -cf collections.yml -pg postgres://127.0.0.1:5432/postgres
              -mdb mongodb://localhost:27017 -n db_name -t
            </code>
            <p>
              If -t is set, Purr starts tailing the oplog after transferring all
              the collections described in the collection map. The oplog is a
              capped collection that records all write operations that happened
              in your Mongo instance. Tailing is started from the timestamp Purr
              saved in the beginning (before it created purr_info). Tailing has
              to happen after all the tables were created since there may be
              write operations on a collection that was not yet transferred and
              therefore it's corresponding relation does not yet exist.Start
              Mongo as a replicaset.
            </p>

            <h2>Changing the Collection Map</h2>
            <p>
              Sooner or later you will need to change your collection map. If
              you restart Purr and keep your existing schema, your tables'
              fields in PG will be compared to the ones in your collection map.
            </p>
            <li>
              Adding a new attribute will make Purr update your entire
              collection.
            </li>
            <li>Removing an attribute drops the column.</li>
            <li>
              Changing a column name will drop the old column, create the new
              one and update your entire collection.
            </li>
            <li>
              Changing a column type will result with an attempt to ALTER the
              column. If the attempt was unsuccessful, Purr will try to convert
              your data to JSONB.
            </li>
            <p>
              What about the tables in my Postgres database that were in the
              schema before using Purr?
            </p>
            <p>
              If you have any existing tables in your schema that you want to be
              left alone, make sure that you
            </p>
            <ul>
              <li>
                don't include those tables in your collection map as a target
                (:meta: :table: cat)
              </li>
              <li>
                set schema_reset to false
              </li>
              <li>
                set table_drop to false
              </li>
              <li>
                set table_truncate to false
              </li>
            </ul>

            <h2>Tailing</h2>
            <p>There are two types of tailing:</p>
            <ul>
              <li>
                tailing which is preceded by collection transfer
              </li>
              <li>
                tailing from specific timestamp (only if collections exist)
              </li>
            </ul>

            <p>
              Tailing without collection transfer must have a starting point
              defined by the user. This starting point can be a timestamp which
              can be passed using -ts datetime. Purr creates a table called
              purr_info where it saves the current Unix epoch time. This
              timestamp is updated every x minutes. The update happens only if
              the current document is successfully transfered. When an error
              occurs, you can be sure that Purr saved the latest successful
              timestamp to purr_info and can continue tailing the oplog from
              -tsdb. purr_info is always created when you first start Purr. If
              you do not add any timestamps to -s:
            </p>

            <ul>
              <li>
                the current timestamp will be inserted
              </li>
              <li>
                it will read the latest timestamp and check if the oplog has any
                new entries
              </li>
              <li>
                if the timestamp is "too old", Purr updates all collections
              </li>
            </ul>
            <p>if the timestamp is "too old", Purr updates all collections</p>
            <ul>
              <li>the latest timestamp will be inserted into purr_info</li>
            </ul>

            <h2>Output</h2>
            <p>
              Purr will log a warning if it could not transfer a document.
            </p>

            <h4>
              Connectivity issues
            </h4>
            <p>
              In the begging, Purr creates a table called purr_info. This table
              contains a timestamp which is refreshed every x minutes in case of
              a successful transfer. If Purr is disconnected from the database,
              it waits a couple of seconds before attempting to reconnect. If
              succeeded, Purr first checks purr_info for the latest timestamp it
              managed to save and continues tailing from there.
            </p>
            <h4>
              Contribute
            </h4>
            Purr is an open-source project that was built using Python3. If you
            would like to contribute, check out our guidelines
            <h3>Guidelines</h3>
            <p>
              Contributing to Purr is a great way to learn more about MongoDB,
              Python and PostgreSQL
            </p>
            <hr />
          </div>
        </div>
        <div class="col-md-1"></div>
      </div>
    </div>
    <div class="footer">
      <p>2019 <span>Booster Fuels</span>, Inc., All Rights Reserved</p>
    </div>
  </body>
</html>
